#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use 5.010000;
use autodie;
use FindBin;
use lib "$FindBin::Bin/local/lib/perl5/";
use Text::MicroTemplate qw(render_mt);

&main; exit;

sub main {
    my ($bank_names, $ops) = read_ops();
    my $tmpl = join('', <DATA>);
    spew('src/gen.assembler.h', render_mt($tmpl, $bank_names, $ops));
}

#   sub make_method_list {
#       my ($bank_names, $ops) = read_ops();
#       my @method_list;
#       while (my ($bank_num, $oplist) = %$ops) {
#           for my $op (@$oplist) {
#               if ($op->[2] !~ /\S/) {
#                   push @method_list,{
#                       name => $op->[1],
#                       bank => "MVM_OP_BANK_" . $bank_names->{$bank_num},
#                       op   => "MVM_OP_$op->[1]"
#                   };
#               }
#           }
#       }
#   }

sub read_ops {
    open my $fh, '<', '3rd/MoarVM/src/core/oplist';
    my $bank_num;
    my %ops;
    my %bank_names;
    my $bank_name;
    while (<$fh>) {
        chomp;
        if (/^BANK ([0-9]+) (\S+)$/) {
            $bank_num  = $1;
            $bank_name = $2;
            $bank_names{$1} = $2;
        } elsif (/^(0x..)\s+(\S+)\s*(.*?)\z/) {
            my $op = {
              hex  => $1,
              name => $2,
              bank => $bank_name,
            };
            $op->{methname} = do {
                +{
                    goto => 'goto_',
                    'return' => 'return_',
                }->{$op->{name}} || $op->{name};
            };
            my @args = split /\s+/, $3;
            my $i=1;
            ($op->{metharg}, $op->{writers}) = metharg(@args);
            $op->{args} = \@args;
            push @{$ops{$bank_num}}, $op;
        }
    }
    return (\%bank_names, \%ops);
}

sub metharg {
    my @ret;
    for (@_) {
        if (/\Ar\(/) {
            push @ret, "uint16_t"
        } elsif (/\Aw\(/) {
            push @ret, "uint16_t";
        } elsif (/\Arl\(`1`\)\z/) {
            push @ret, "uint16_t", 'uint16_t';
        } elsif ($_ eq 'wl(`1)') {
            push @ret, 'uint16_t', 'uint16_t';
        } elsif ($_ eq 'rl(`1)') {
            push @ret, 'uint16_t', 'uint16_t';
        } elsif ($_ eq 'str') {
            push @ret, "uint16_t";
        } elsif ($_ eq 'callsite') {
            push @ret, "uint16_t";
        } elsif ($_ eq 'ins') {
            push @ret, "uint32_t";
        } elsif ($_ eq 'int8') {
            push @ret, "int8_t";
        } elsif ($_ eq 'int16') {
            push @ret, "int16_t";
        } elsif ($_ eq 'int32') {
            push @ret, "int32_t";
        } elsif ($_ eq 'int64') {
            push @ret, "int64_t";
        } elsif ($_ eq 'num32') {
            push @ret, "MVMnum32";
        } elsif ($_ eq 'num64') {
            push @ret, "MVMnum64";
        } elsif ($_ eq 'coderef') {
            push @ret, "uint16_t";
        } else {
            die $_;
        }
    }
    my $i = 1;
    my $metharg = join(', ', map { sprintf('%s op%d', $_, $i++) } @ret);
    $i=1;
    my $writers = [map { writer($_, $i++) } @ret];
    return ($metharg, $writers);
}

sub writer {
    my ($type, $i) = @_;
    "write_$type(op$i);";
}

sub spew {
    my $fname = shift;
    open my $fh, '>', $fname
        or Carp::croak("Can't open '$fname' for writing: '$!'");
    print {$fh} $_[0];
}

__DATA__
? my ($bank_names, $ops) = @_;
// This file is generated by build/asm.pl
#pragma once
// vim:ts=2:sw=2:tw=0:

#include <string>
#include <vector>
#include <stdint.h>

namespace saru {
  class Assembler {
  public:
    void op(MVMuint8 bank_num, MVMuint8 op_num) {
      if (0) {
        MVMOpInfo *op = MVM_op_get_op(bank_num, op_num);
        printf("%d %d %s\n", bank_num, op_num, op->name);
      }
      write_u8(bank_num);
      write_u8(op_num);
    }
    void op_u16(MVMuint8 bank_num, MVMuint8 op_num, uint16_t op1) {
      op(bank_num, op_num);
      write_u16(op1);
    }
    void op_u16_u16(MVMuint8 bank_num, MVMuint8 op_num, uint16_t op1, uint16_t op2) {
      op(bank_num, op_num);
      write_u16(op1);
      write_u16(op2);
    }
    void op_u16_u32(MVMuint8 bank_num, MVMuint8 op_num, uint16_t op1, uint16_t op2) {
      op(bank_num, op_num);
      write_u16(op1);
      write_uint32_t(op2);
    }
    void op_u16_u16_u16(MVMuint8 bank_num, MVMuint8 op_num, uint16_t op1, uint16_t op2, uint16_t op3) {
      op(bank_num, op_num);
      write_u16(op1);
      write_u16(op2);
      write_u16(op3);
    }
    void op_u16_i64(MVMuint8 bank_num, MVMuint8 op_num, uint16_t op1, int64_t op2) {
      op(bank_num, op_num);
      write_u16(op1);
      write_i64(op2);
    }
    void op_u16_n64(MVMuint8 bank_num, MVMuint8 op_num, uint16_t op1, MVMnum64 op2) {
      op(bank_num, op_num);
      write_u16(op1);
      write_n64(op2);
    }
    void write_u8(MVMuint8 i) {
      bytecode_.push_back(i);
    }
    void write_u16(MVMuint16 i) {
      bytecode_.push_back((i>>0)  &0xffff);
      bytecode_.push_back((i>>8)  &0xffff);
    }
    void write_16(uint32_t i) {
      // optmize?
      bytecode_.push_back((i>>0)  &0xffff);
      bytecode_.push_back((i>>8)  &0xffff);
      bytecode_.push_back((i>>16) &0xffff);
      bytecode_.push_back((i>>24) &0xffff);
    }
    void write_int8_t(int8_t i) {
      // optmize?
      static char buf[1];
      memcpy(buf, &i, 1); // TODO endian
      for (int i=0; i<1; i++) {
        bytecode_.push_back(buf[i]);
      }
    }
    void write_int16_t(int16_t i) {
      // optmize?
      static char buf[2];
      memcpy(buf, &i, 2); // TODO endian
      for (int i=0; i<2; i++) {
        bytecode_.push_back(buf[i]);
      }
    }
    void write_uint32_t(uint32_t i, size_t pos) {
      // optmize?
      static char buf[4];
      memcpy(buf, &i, 4); // TODO endian
      for (int i=0; i<4; i++) {
        bytecode_[pos+i] = buf[i];
      }
    }
    void write_uint16_t(uint16_t i, size_t pos) {
      // optmize?
      static char buf[2];
      memcpy(buf, &i, 2); // TODO endian
      for (int i=0; i<2; i++) {
        bytecode_[pos+i] = buf[i];
      }
    }
    void write_uint16_t(uint16_t i) {
      // optmize?
      static char buf[2];
      memcpy(buf, &i, 2); // TODO endian
      for (int i=0; i<2; i++) {
        bytecode_.push_back(buf[i]);
      }
    }
    void write_int32_t(int32_t i) {
      // optmize?
      static char buf[4];
      memcpy(buf, &i, 4); // TODO endian
      for (int i=0; i<4; i++) {
        bytecode_.push_back(buf[i]);
      }
    }
    void write_uint32_t(uint32_t i) {
      // optmize?
      static char buf[4];
      memcpy(buf, &i, 4); // TODO endian
      for (int i=0; i<4; i++) {
        bytecode_.push_back(buf[i]);
      }
    }
    void write_int64_t(int64_t i) {
      // optmize?
      static char buf[8];
      memcpy(buf, &i, 8); // TODO endian
      for (int i=0; i<8; i++) {
        bytecode_.push_back(buf[i]);
      }
    }
    void write_uint64_t(uint64_t i) {
      // optmize?
      static char buf[8];
      memcpy(buf, &i, 8); // TODO endian
      for (int i=0; i<8; i++) {
        bytecode_.push_back(buf[i]);
      }
    }
    void write_MVMnum32(MVMnum32 i) {
      // optmize?
      static char buf[4];
      memcpy(buf, &i, 4); // TODO endian
      for (int i=0; i<4; i++) {
        bytecode_.push_back(buf[i]);
      }
    }
    void write_MVMnum64(MVMnum64 i) {
      // optmize?
      static char buf[8];
      memcpy(buf, &i, 8); // TODO endian
      for (int i=0; i<8; i++) {
        bytecode_.push_back(buf[i]);
      }
    }
    void write_n64(MVMnum64 i) {
      // optmize?
      static char buf[8];
      memcpy(buf, &i, 8); // TODO endian
      for (int i=0; i<8; i++) {
        bytecode_.push_back(buf[i]);
      }
    }
    void write_i64(int64_t i) {
      // optmize?
      static char buf[8];
      memcpy(buf, &i, 8); // TODO endian
      for (int i=0; i<8; i++) {
        bytecode_.push_back(buf[i]);
      }
    }
    MVMuint8* bytecode() {
      return bytecode_.data(); // C++11
    }
    size_t bytecode_size() {
      return bytecode_.size();
    }
? for my $bank_num (sort keys %$ops) {
    // <?= $bank_num ?>
?   for my $op (@{$ops->{$bank_num}}) {
      void <?= $op->{methname} ?>(<?= $op->{metharg} ?>) {
         op(MVM_OP_BANK_<?= $op->{bank} ?>, MVM_OP_<?= $op->{name} ?>);
?        for my $writer (@{$op->{writers}}) {
            <?= $writer ?>
?        }
      }
?   }
? }
  private:
    std::vector<MVMuint8> bytecode_;
  };
};
