#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use 5.010000;
use autodie;
use FindBin;
use lib "$FindBin::Bin/local/lib/perl5/";
use Text::MicroTemplate qw(render_mt);

&main; exit;

sub main {
    my ($bank_names, $ops) = read_ops();
    my $tmpl = join('', <DATA>);
    my $mt = Text::MicroTemplate->new(template => $tmpl, escape_func => sub { $_[0] } );
    my $code = $mt->build();
    spew('src/gen.assembler.h', $code->($bank_names, $ops));
}

#   sub make_method_list {
#       my ($bank_names, $ops) = read_ops();
#       my @method_list;
#       while (my ($bank_num, $oplist) = %$ops) {
#           for my $op (@$oplist) {
#               if ($op->[2] !~ /\S/) {
#                   push @method_list,{
#                       name => $op->[1],
#                       bank => "MVM_OP_BANK_" . $bank_names->{$bank_num},
#                       op   => "MVM_OP_$op->[1]"
#                   };
#               }
#           }
#       }
#   }

sub read_ops {
    open my $fh, '<', '3rd/MoarVM/src/core/oplist';
    my $bank_num;
    my %ops;
    my %bank_names;
    my $bank_name;
    my %seen;
    while (<$fh>) {
        chomp;
        if (/^BANK ([0-9]+) (\S+)$/) {
            $bank_num  = $1;
            $bank_name = $2;
            $bank_names{$1} = $2;
        } elsif (/^(0x..)\s+(\S+)\s*(.*?)\z/) {
            my $op = {
              hex  => $1,
              name => $2,
              bank => $bank_name,
            };
            $op->{methname} = $op->{name};
            $op->{methname} =~ tr/a-zA-Z/A-Za-z/;
            my @args = split /\s+/, $3;
            ($op->{params}, $op->{types}) = metharg(@args);
            $op->{args} = \@args;
            push @{$ops{$bank_num}}, $op;
        }
    }
    use Data::Dumper; warn Dumper(\%ops);
    return (\%bank_names, \%ops);
}

sub metharg {
    my @ret;
    for (@_) {
        if (/\Ar\(/) {
            push @ret, "uint16_t"
        } elsif (/\Aw\(/) {
            push @ret, "uint16_t";
        } elsif (/\Arl\(`1`\)\z/) {
            push @ret, "uint16_t", 'uint16_t';
        } elsif ($_ eq 'wl(`1)') {
            push @ret, 'uint16_t', 'uint16_t';
        } elsif ($_ eq 'rl(`1)') {
            push @ret, 'uint16_t', 'uint16_t';
        } elsif ($_ eq 'str') {
            push @ret, "uint16_t";
        } elsif ($_ eq 'callsite') {
            push @ret, "uint16_t";
        } elsif ($_ eq 'ins') {
            push @ret, "uint32_t";
        } elsif ($_ eq 'int8') {
            push @ret, "int8_t";
        } elsif ($_ eq 'int16') {
            push @ret, "int16_t";
        } elsif ($_ eq 'int32') {
            push @ret, "int32_t";
        } elsif ($_ eq 'int64') {
            push @ret, "int64_t";
        } elsif ($_ eq 'num32') {
            push @ret, "MVMnum32";
        } elsif ($_ eq 'num64') {
            push @ret, "MVMnum64";
        } elsif ($_ eq 'coderef') {
            push @ret, "uint16_t";
        } else {
            die $_;
        }
    }
    my $i = 1;
    my @params  = map { sprintf('op%d', $i++) } @ret;
    my @types   = @ret;
    return (\@params, \@types);
}

sub spew {
    my $fname = shift;
    open my $fh, '>', $fname
        or Carp::croak("Can't open '$fname' for writing: '$!'");
    print {$fh} $_[0];
}

__DATA__
#pragma once
? my ($bank_names, $ops) = @_;
/* This file is generated by build/asm.pl */

? for my $bank_num (sort keys %$ops) {
/* BANK: <?= $bank_num ?> */
?   for my $op (@{$ops->{$bank_num}}) {
#define ASM_<?= $op->{methname} ?>(<?= join(',', @{$op->{params}}) ?>) \\
  do { \\
?        for my $i (0..@{$op->{params}}-1) {
    <?= $op->{types}->[$i] ?> _<?= $op->{params}->[$i] ?> = <?= $op->{params}->[$i] ?>; \\
?        }
    Kiji_asm_op(&(*(frames_.back())), MVM_OP_BANK_<?= $op->{bank} ?>, MVM_OP_<?= $op->{name} ?>); \\
?        for my $i (0..@{$op->{params}}-1) {
        Kiji_asm_write_<?= $op->{types}->[$i] ?>(&(*(frames_.back())), _<?= $op->{params}->[$i] ?>); \\
?        }
  } while(0)

?   }
? }
